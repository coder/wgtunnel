package tunneld

import (
	"crypto/sha256"
	"encoding/base32"
	"net"
	"net/netip"
	"net/url"
	"strings"

	"golang.org/x/xerrors"
	"golang.zx2c4.com/wireguard/device"

	"cdr.dev/slog"
	"github.com/coder/wgtunnel/tunnelsdk"
)

const (
	DefaultWireguardMTU = 1280
)

var (
	DefaultWireguardServerIP      = netip.MustParseAddr("fcca::1")
	DefaultWireguardNetworkPrefix = netip.MustParsePrefix("fcca::/64")
)

var hostnameEncoder = base32.HexEncoding.WithPadding(base32.NoPadding)

type Options struct {
	Log slog.Logger

	// BaseURL is the base URL to use for the tunnel, including scheme. All
	// tunnels will be subdomains of this hostname.
	// e.g. "https://tunnel.example.com" will place tunnels at
	//      "https://xyz.tunnel.example.com"
	BaseURL *url.URL

	// WireguardEndpoint is the UDP address advertised to clients that they will
	// connect to for wireguard connections. It should be in the form
	// "$ip:$port" or "$hostname:$port".
	WireguardEndpoint string
	// WireguardPort is the UDP port that the wireguard server will listen on.
	// It should be the same as the port in WireguardEndpoint.
	WireguardPort uint16
	// WireguardKey is the private key for the wireguard server.
	WireguardKey tunnelsdk.Key

	// WireguardMTU is the MTU to use for the wireguard interface. Defaults to
	// 1280.
	WireguardMTU int
	// WireguardServerIP is the virtual IP address of this server in the
	// wireguard network. Must be an IPv6 address contained within
	// WireguardNetworkPrefix. Defaults to fcca::1.
	WireguardServerIP netip.Addr
	// WireguardNetworkPrefix is the CIDR of the wireguard network. All client
	// IPs will be generated within this network. Must be a IPv6 CIDR and have
	// at least 64 bits of space available. Defaults to fcca::0/64.
	WireguardNetworkPrefix netip.Prefix
}

// Validate checks that the options are valid and populates default values for
// missing fields.
func (options *Options) Validate() error {
	if options == nil {
		return xerrors.New("options is nil")
	}
	if options.BaseURL == nil {
		return xerrors.New("BaseURL is required")
	}
	if options.WireguardEndpoint == "" {
		return xerrors.New("WireguardEndpoint is required")
	}
	_, _, err := net.SplitHostPort(options.WireguardEndpoint)
	if err != nil {
		return xerrors.Errorf("WireguardEndpoint %q is not a valid host:port combination: %w", options.WireguardEndpoint, err)
	}
	if options.WireguardPort == 0 {
		return xerrors.New("WireguardPort is required")
	}
	if options.WireguardKey.IsZero() {
		return xerrors.New("WireguardKey is required")
	}
	if !options.WireguardKey.IsPrivate() {
		return xerrors.New("WireguardKey must be a private key")
	}
	// Key is parsed and validated when the server is started.
	if options.WireguardMTU <= 0 {
		options.WireguardMTU = DefaultWireguardMTU
	}
	if options.WireguardServerIP.BitLen() == 0 {
		options.WireguardServerIP = DefaultWireguardServerIP
	}
	if options.WireguardServerIP.BitLen() != 128 {
		return xerrors.New("WireguardServerIP must be an IPv6 address")
	}
	if options.WireguardNetworkPrefix.Bits() <= 0 {
		options.WireguardNetworkPrefix = DefaultWireguardNetworkPrefix
	}
	if options.WireguardNetworkPrefix.Bits() > 64 {
		return xerrors.New("WireguardNetworkPrefix must have at least 64 bits available")
	}
	if !options.WireguardNetworkPrefix.Contains(options.WireguardServerIP) {
		return xerrors.New("WireguardServerIP must be contained within WireguardNetworkPrefix")
	}

	return nil
}

// WireguardPublicKeyToIP returns the IP address that corresponds to the given
// wireguard public key.
func (options *Options) WireguardPublicKeyToIP(publicKey device.NoisePublicKey) netip.Addr {
	var (
		keyHash   = sha256.Sum256(publicKey[:])
		addrBytes = options.WireguardNetworkPrefix.Addr().As16()
	)

	// Copy the first 8 bytes of the hash to the last 8 bytes of the address. We
	// only use 8 bytes because we only store 8 bytes of information in the
	// generated hostname.
	//
	// The prefix has at least 64 bits of space available, so we can safely
	// overwrite the last 8 bytes.
	copy(addrBytes[8:], keyHash[:8])

	return netip.AddrFrom16(addrBytes)
}

// WireguardIPToTunnelURL converts an IPv6 address's last 8 bytes to a base32
// encoded hostname and then creates a full tunnel URL from the configured
// BaseURL. We only use the last 8 bytes as it's assumed the IP address was
// generated by WireguardPublicKeyToIP, which only stores significant
// information in the last 8 bytes.
func (options *Options) WireguardIPToTunnelURL(addr netip.Addr) *url.URL {
	addrBytes := addr.As16()
	encoded := hostnameEncoder.EncodeToString(addrBytes[8:])

	u := *options.BaseURL
	u.Host = strings.ToLower(encoded) + "." + u.Host
	return &u
}

// HostnameToWireguardIP returns the wireguard IP address that corresponds to a
// given encoded hostname label as generated by wireguardIPToHostname.
func (options *Options) HostnameToWireguardIP(hostname string) (netip.Addr, error) {
	decoded, err := hostnameEncoder.DecodeString(strings.ToUpper(hostname))
	if err != nil {
		return netip.Addr{}, xerrors.Errorf("decode hostname %q as base32: %w", hostname, err)
	}
	if len(decoded) != 8 {
		return netip.Addr{}, xerrors.Errorf("invalid hostname length: got %d, expected 8", len(decoded))
	}

	addrBytes := options.WireguardNetworkPrefix.Addr().As16()
	copy(addrBytes[8:], decoded[:])

	return netip.AddrFrom16(addrBytes), nil
}
